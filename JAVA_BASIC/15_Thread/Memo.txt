스레드(Thread) =====

프로세스(Process) -> 실행중인 프로그램
프로세스는 프로그램이 실행될 때마다 개별적으로 생성
하나의 프로세스는 프로그램을 수행함에 있어 필요한 데이터와 메모리 등의 할당 받은 자원,
그리고 하나 이상의 스레드로 구성됨

& 하나의 프로세스안에는 하나이상의 쓰레드가 들어가야만 한다.

스레드(Thread)
프로세스 내에서 할당된 자원을 이용해서 (실제 작업을 수행하는 작업단위)
모든 프로세스는 하나 이상의 스레드를 가지며 각각 독립적인 작업단위를 가짐

& SCV
& 프로세스 안에서 실제로 작업을 수행하는 아

메인 스레드
모든 자바 프록그램은 메인 스레드가 main() 메소드를 실행하며 시작
main()의 첫 코드부터 아래로 순차적으로 실행되고, return 을 만나면 종료
필요에 의해 작업 스레드들을 만들어서 병렬 코드 실행 가능
(멀티 스레드를 이용한 멀티 태스킹)

메인 스레드가 메인메소드 실행하면서 시작

프로세스 종료
싱글 스레드의 경우 메인 스레드가 종료되면 프로세스도 종료되지만,
멀티 스레드의 경우 실행 중인 스레드가 하나라도 있다면 프로세스가 종료되지 않음


& 멀티 스레드 와  멀티 프로세스 차이 혼동 주의
-> 멀티 프로세스 : 실행중인 프로그램이 여러개가 있다.
-> 멀티 스레드 : 하나의 프로세스중에서 여러개의 스레드가 일을 할 수 있는것
메인 스레드 외의 추가적인 스레드를 이용하여 병렬적으로 작업 처리


멀티스레드 장점
- 자원을 보다 효율적으로 사용 가능
- 사용자의 대한 응답성 향상
- 애플리케이션의 응답성 향상
- 작업이 분리되어 코드가 간결해짐
- CPU 사용률 향상

단점
- 동기화(Synchronization)에 주의
- 교착상태(dead-lock)가 발생하지 않도록 주의

동기화.
 스레드에서 자원을 가져가 와서 일을 해야하는데
 여러 스레드에서  동시에 하나의 자원을 공유하게 되면 꼬일수가 있기에
 자원을 사용할떄 스레드들을 줄을 세워서 막아놓는것
 
 교착상태 . 서로 기다리면서 서로 일을 못하고 있는 상태
 
 
구현방법 
1. 스레드를 상속받는것 -> 객체생성만 하면 끝난다.
스레드를 상속받으면 start라는 메소드가 있기에 바로 가져다 써도 되진다.

public class 클래스명 extends Thread{
	@Override
	public void run(){
	
	}
}
public class Run {
	public static void main(String[] args){
		클래스명 레퍼런스 = new 생성자();
		레퍼런스.start();
		}
}

2. Runnable 인터페이를 상속받아서 구현 -> 스레드에 대한 객체에다가 넣어줬어야한다.

public class 클래스명 implements Runnable{
	@override
	public void run(){
	
	}
}

public class Run{
	public static void main(String[] args){
		클래스명 레퍼런스 = new 생성자();
		
		Thread thread = new Thread(레퍼런스);
		thread.start();
	}
}

겉으로는 똑같아 보여도
실제로 메모리에서 실행되는것은 완전히 다르다.
start() 메소드가 새로운 스레드를 생성하고 그 위에 run() 메소드가 쌓임
 
우선순위 스케쥴링 방식
- 숫자가 높을수록 우선순위가 높다.


@스레드 컨트롤 부분이 상당히 어렵다.
@통신쪽을 하게되면 많이 보게된다.


스레드 컨트롤
실행 중인 스레드의 상태를 제어하기 위한 것으로
효율적이고 정교한 스케쥴링을 위한 스레드 상태를 제어하는 기능
-> 일시정지 상태에 머문다.

실행 -> 일시정지 -> 실행대기 
sleep()
join()
wait()
I/O block 

1/30일 시험
2/12 일 쉰다.

동기화 - 하나의 쓰레드만 접근할 수 있도록 락을 걸어두는것

